<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Diploma Thesis DAW-Controller: Button Matrix: Header</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mdw_Logo_weiss.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">Diploma Thesis DAW-Controller: Button Matrix<span id="projectnumber">&#160;Demo Project</span>
   </div>
   <div id="projectbrief">This Project shows how to setup and use a button matrix.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group___buffer___ping_pong___header.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">Header<div class="ingroups"><a class="el" href="group___m_i_d_i___u_a_r_t.html">Module to transfer MIDI over UART.</a> &raquo; <a class="el" href="group___buffer___ping_pong.html">Ping-Pong Buffer used for Data Transfer</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Study this part for a quick overview of this module.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:_buffer___ping_pong_8h" id="r__buffer___ping_pong_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_buffer___ping_pong_8h.html">Buffer_PingPong.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to buffer data for DMA Transmission. The buffering works with a ping-pong principle.  <a href="struct_buffer_ping_pong__struct_td.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga52bf03617fcd1eeaad907e7e45245ba5" id="r_ga52bf03617fcd1eeaad907e7e45245ba5"><td class="memItemLeft" align="right" valign="top"><a id="ga52bf03617fcd1eeaad907e7e45245ba5" name="ga52bf03617fcd1eeaad907e7e45245ba5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PINGPONG_RX_MAX</b>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:ga52bf03617fcd1eeaad907e7e45245ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define size of the RX Buffers here. Max Value: 65535 - 1 (16Bit, 0xFFFF is reserved for Error). <br /></td></tr>
<tr class="separator:ga52bf03617fcd1eeaad907e7e45245ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99520cf134125594f94d15ccf1630188" id="r_ga99520cf134125594f94d15ccf1630188"><td class="memItemLeft" align="right" valign="top"><a id="ga99520cf134125594f94d15ccf1630188" name="ga99520cf134125594f94d15ccf1630188"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PINGPONG_TX_MAX</b>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:ga99520cf134125594f94d15ccf1630188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define size of the TX Buffers here. Max Value: 65535 - 1 (16Bit, 0xFFFF is reserved for Error). <br /></td></tr>
<tr class="separator:ga99520cf134125594f94d15ccf1630188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb05503f67fd585b6310ec20d33cedf1" id="r_gafb05503f67fd585b6310ec20d33cedf1"><td class="memItemLeft" align="right" valign="top"><a id="gafb05503f67fd585b6310ec20d33cedf1" name="gafb05503f67fd585b6310ec20d33cedf1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PINGPONG_RX_HEADROOM</b>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:gafb05503f67fd585b6310ec20d33cedf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define size of the RX Buffer headroom. It is used to buffer byte by byte until an expected Data Block is full. Then it will be latched to the buffer. <br /></td></tr>
<tr class="separator:gafb05503f67fd585b6310ec20d33cedf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ab40baeb2e52e8aa001be73801eba2" id="r_gae3ab40baeb2e52e8aa001be73801eba2"><td class="memItemLeft" align="right" valign="top"><a id="gae3ab40baeb2e52e8aa001be73801eba2" name="gae3ab40baeb2e52e8aa001be73801eba2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFER_PING_PONG_ERROR_VALUE_RESERVE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae3ab40baeb2e52e8aa001be73801eba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value that is subtracted from value ranges to reserve the binary max vale (0xFF..) for errors. <br /></td></tr>
<tr class="separator:gae3ab40baeb2e52e8aa001be73801eba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Structure and Enumerations</h2></td></tr>
<tr class="memitem:ga3b2c69341c212dc2ffaaeb267d2909a3" id="r_ga3b2c69341c212dc2ffaaeb267d2909a3"><td class="memItemLeft" align="right" valign="top"><a id="ga3b2c69341c212dc2ffaaeb267d2909a3" name="ga3b2c69341c212dc2ffaaeb267d2909a3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b2c69341c212dc2ffaaeb267d2909a3">BufferPingPong_Td</a> { <br />
&#160;&#160;<b>BUFFER_PINGPONG_NONE</b> = 0x00
, <b>BUFFER_PINGPONG_TX_A</b> = 0x10
, <b>BUFFER_PINGPONG_TX_B</b> = 0x11
, <b>BUFFER_PINGPONG_RX_A</b> = 0x12
, <br />
&#160;&#160;<b>BUFFER_PINGPONG_RX_B</b> = 0x13
<br />
 }</td></tr>
<tr class="memdesc:ga3b2c69341c212dc2ffaaeb267d2909a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerations to describe the buffer and buffer-internal states. <br /></td></tr>
<tr class="separator:ga3b2c69341c212dc2ffaaeb267d2909a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37f8934f053404c91bdbe4dfc1f906b3" id="r_ga37f8934f053404c91bdbe4dfc1f906b3"><td class="memItemLeft" align="right" valign="top"><a id="ga37f8934f053404c91bdbe4dfc1f906b3" name="ga37f8934f053404c91bdbe4dfc1f906b3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BufferPingPong_error_Td</b> { <br />
&#160;&#160;<b>BUFFER_PINGPONG_ERROR_NONE</b> = 0x00
, <b>BUFFER_PINGPONG_ERROR_TX_A_OVERFLOW</b> = 0x10
, <b>BUFFER_PINGPONG_ERROR_TX_B_OVERFLOW</b> = 0x11
, <b>BUFFER_PINGPONG_ERROR_RX_A_OVERFLOW</b> = 0x12
, <br />
&#160;&#160;<b>BUFFER_PINGPONG_ERROR_RX_B_OVERFLOW</b> = 0x13
, <b>BUFFER_PINGPONG_ERROR_NO_BUFFER_FOUND</b> = 0x20
, <b>BUFFER_PINGPONG_ERROR_TOGGLE_RX_FAILED</b> = 0x30
, <b>BUFFER_PINGPONG_ERROR_TOGGLE_TX_FAILED</b> = 0x31
, <br />
&#160;&#160;<b>BUFFER_PINGPONG_ERROR_RX_MAX_TOO_HIGH</b> = 0x40
, <b>BUFFER_PINGPONG_ERROR_TX_MAX_TOO_HIGH</b> = 0x41
, <b>BUFFER_PINGPONG_ERROR_RX_HEADROOM_TOO_HIGH</b> = 0x41
, <b>BUFFER_PINGPONG_ERROR_16BIT_RANGE_OVERFLOW</b> = 0x50
, <br />
&#160;&#160;<b>BUFFER_PINGPONG_OVERFLOW</b> = 0xFF
<br />
 }</td></tr>
<tr class="separator:ga37f8934f053404c91bdbe4dfc1f906b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialize</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Use these functions to initialize this module. </p>
</td></tr>
<tr class="memitem:gac930abb339112617a8c77d49fd46cc56" id="r_gac930abb339112617a8c77d49fd46cc56"><td class="memItemLeft" align="right" valign="top">BufferPingPong_error_Td&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac930abb339112617a8c77d49fd46cc56">BufferPingPong_init_StartConditions</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:gac930abb339112617a8c77d49fd46cc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function once in the beginning to initialize the start conditions of the buffers data structure. BUFFER_PINGPONG_RX_MAX and BUFFER_PINGPONG_TX_MAX will be checked, if the value is valid.  <br /></td></tr>
<tr class="separator:gac930abb339112617a8c77d49fd46cc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Rx Buffer on Application Side</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>This function are used to access the Buffer in the users application.</p>
<h1><a class="anchor" id="autotoc_md41"></a>
How to implement</h1>
<ol type="1">
<li>Check if new data is available (This has to be checked manually, depending on the way, how the data reception works in the applications environment). Continue, if new data is available.</li>
<li>Get the start pointer of the index, that was filled with data from the transmission side (<a class="el" href="#ga3f2b28c4822a9be417e6d99a51bd39a8" title="Get the size of the Rx Buffer that contains new data.">BufferPingPong_fetch_SizeOfFilledRxBuffer()</a>)</li>
<li>Get the size of data inside this buffer (<a class="el" href="#ga0e17314f4db745d45752fd676a93a25a" title="Get the start point of the RxArray that contains new data.">ButterPingPong_fetch_StartPtrOfFilledRxBuffer()</a>)</li>
<li>toggle the Rx Buffer, so the transmitter can fill the other buffer, while the filled buffer is in use. (<a class="el" href="#ga41cd11b371bd0c90d0283c21f4c0a6db" title="Toggle the buffer that is used to receive data, so the filled one gets free to use....">BufferPingPong_toggle_RxBuffer()</a>)</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The Rx Buffer must not be toggled before the start pointer and the buffer size are fetched, otherwise the return of these functions will be wrong. </dd></dl>
</td></tr>
<tr class="memitem:ga0e17314f4db745d45752fd676a93a25a" id="r_ga0e17314f4db745d45752fd676a93a25a"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0e17314f4db745d45752fd676a93a25a">ButterPingPong_fetch_StartPtrOfFilledRxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:ga0e17314f4db745d45752fd676a93a25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start point of the RxArray that contains new data.  <br /></td></tr>
<tr class="separator:ga0e17314f4db745d45752fd676a93a25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2b28c4822a9be417e6d99a51bd39a8" id="r_ga3f2b28c4822a9be417e6d99a51bd39a8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f2b28c4822a9be417e6d99a51bd39a8">BufferPingPong_fetch_SizeOfFilledRxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:ga3f2b28c4822a9be417e6d99a51bd39a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Rx Buffer that contains new data.  <br /></td></tr>
<tr class="separator:ga3f2b28c4822a9be417e6d99a51bd39a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41cd11b371bd0c90d0283c21f4c0a6db" id="r_ga41cd11b371bd0c90d0283c21f4c0a6db"><td class="memItemLeft" align="right" valign="top">BufferPingPong_error_Td&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41cd11b371bd0c90d0283c21f4c0a6db">BufferPingPong_toggle_RxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:ga41cd11b371bd0c90d0283c21f4c0a6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the buffer that is used to receive data, so the filled one gets free to use. Make sure to fetch the Start pointer and size of the filled buffer before toggling!  <br /></td></tr>
<tr class="separator:ga41cd11b371bd0c90d0283c21f4c0a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Rx Buffer on Transmission Side</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>This function are used to handle the Rx Buffers on transmission side. This can be anything, that actually receives data bytes and stores them in an any buffer.</p>
<h1><a class="anchor" id="autotoc_md42"></a>
How to implement</h1>
<ol type="1">
<li>Latch the temporary data, that contains data from the previous Rx Cycle, to the regular Rx Buffer. The temporary buffer can get overwritten now. (This step should be skipped for the first rx cycle, because the temporary buffer will be empty)</li>
<li>Get the start pointer of the temporary data buffer. This buffer will be used to store data, until a reception cycle is finished.</li>
<li>Get the Size of the maximum size of the temporary buffer to avoid overflow</li>
<li>Use the received pointer and size to initiate a new data reception cycle. The following received data should be stored here. </li>
</ol>
</td></tr>
<tr class="memitem:ga0e5c4f95c7506ea13d72baa93faf6535" id="r_ga0e5c4f95c7506ea13d72baa93faf6535"><td class="memItemLeft" align="right" valign="top">BufferPingPong_error_Td&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0e5c4f95c7506ea13d72baa93faf6535">BufferPingPong_latch_TempRxBufferToRegularRxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer, uint16_t Size)</td></tr>
<tr class="memdesc:ga0e5c4f95c7506ea13d72baa93faf6535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all received data from the temporary buffer to the regular buffer. After latching, the temporary buffer is ready to be filled again.  <br /></td></tr>
<tr class="separator:ga0e5c4f95c7506ea13d72baa93faf6535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b065e8b2062f367f24ff5ec976af2f" id="r_ga10b065e8b2062f367f24ff5ec976af2f"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10b065e8b2062f367f24ff5ec976af2f">BufferPingPong_get_StartPtrOfTempRxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:ga10b065e8b2062f367f24ff5ec976af2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start pointer of the temporary data buffer.  <br /></td></tr>
<tr class="separator:ga10b065e8b2062f367f24ff5ec976af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60951be1c3363f579515a9c0fe80f18c" id="r_ga60951be1c3363f579515a9c0fe80f18c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga60951be1c3363f579515a9c0fe80f18c">BufferPingPong_get_SizeOfTempRxBuffer</a> ()</td></tr>
<tr class="memdesc:ga60951be1c3363f579515a9c0fe80f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum size of the temporary data buffer.  <br /></td></tr>
<tr class="separator:ga60951be1c3363f579515a9c0fe80f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tx Buffer on Application Side</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>This function are used to handle the Tx Buffers </p>
</td></tr>
<tr class="memitem:gaf82e195b46343a5f3d322ae3c226b974" id="r_gaf82e195b46343a5f3d322ae3c226b974"><td class="memItemLeft" align="right" valign="top">BufferPingPong_error_Td&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf82e195b46343a5f3d322ae3c226b974">BufferPingPong_queue_TxBytesToEmptyBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer, uint8_t *Data, uint8_t Size)</td></tr>
<tr class="memdesc:gaf82e195b46343a5f3d322ae3c226b974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to queue data for transmission to the buffer that is free to be filled.  <br /></td></tr>
<tr class="separator:gaf82e195b46343a5f3d322ae3c226b974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tx Buffer on Transmission Side</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>This function are used to handle the Tx Buffers</p>
<h1><a class="anchor" id="autotoc_md43"></a>
How to implement</h1>
<ol type="1">
<li>Get the start pointer of the Tx Buffer, that is filled and should be sent</li>
<li>Get the Size of this buffer</li>
<li>Toggle the Tx buffers</li>
<li>Use the Pointer and Size to start the new send cycle. </li>
</ol>
</td></tr>
<tr class="memitem:ga0eff78cbd4cb2f862b2d5cb908585257" id="r_ga0eff78cbd4cb2f862b2d5cb908585257"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0eff78cbd4cb2f862b2d5cb908585257">BufferPingPong_get_StartPtrOfFilledTxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:ga0eff78cbd4cb2f862b2d5cb908585257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start point of the first free place in the Buffer Array, that is ready to send.  <br /></td></tr>
<tr class="separator:ga0eff78cbd4cb2f862b2d5cb908585257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f7fba4ca0bddfd22bd6fb3e7c8611e" id="r_ga51f7fba4ca0bddfd22bd6fb3e7c8611e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51f7fba4ca0bddfd22bd6fb3e7c8611e">BufferPingPong_get_SizeOfFilledTxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:ga51f7fba4ca0bddfd22bd6fb3e7c8611e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the Array to be send.  <br /></td></tr>
<tr class="separator:ga51f7fba4ca0bddfd22bd6fb3e7c8611e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80cc5f7a82bbf40a0f42bc2d18495ff" id="r_gab80cc5f7a82bbf40a0f42bc2d18495ff"><td class="memItemLeft" align="right" valign="top">BufferPingPong_error_Td&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab80cc5f7a82bbf40a0f42bc2d18495ff">BufferPingPong_toggle_TxBuffer</a> (<a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *Buffer)</td></tr>
<tr class="memdesc:gab80cc5f7a82bbf40a0f42bc2d18495ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the buffer that is used to send data, so the other one gets free for processing.  <br /></td></tr>
<tr class="separator:gab80cc5f7a82bbf40a0f42bc2d18495ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Study this part for a quick overview of this module. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3f2b28c4822a9be417e6d99a51bd39a8" name="ga3f2b28c4822a9be417e6d99a51bd39a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f2b28c4822a9be417e6d99a51bd39a8">&#9670;&#160;</a></span>BufferPingPong_fetch_SizeOfFilledRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t BufferPingPong_fetch_SizeOfFilledRxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the Rx Buffer that contains new data. </p>
<dl class="section return"><dt>Returns</dt><dd>size of the buffered data. 0xFFFF in case of an error. </dd></dl>

</div>
</div>
<a id="ga51f7fba4ca0bddfd22bd6fb3e7c8611e" name="ga51f7fba4ca0bddfd22bd6fb3e7c8611e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f7fba4ca0bddfd22bd6fb3e7c8611e">&#9670;&#160;</a></span>BufferPingPong_get_SizeOfFilledTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t BufferPingPong_get_SizeOfFilledTxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the Array to be send. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called after Buffer_get_TxStartPtrForTransmission(), otherwise it will return the size of the wrong buffer. This function can only be called once for each cycle because the index counter will be reset. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the buffer that will be send. 0 if the buffer is empty or in case of an error. </dd></dl>

</div>
</div>
<a id="ga60951be1c3363f579515a9c0fe80f18c" name="ga60951be1c3363f579515a9c0fe80f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60951be1c3363f579515a9c0fe80f18c">&#9670;&#160;</a></span>BufferPingPong_get_SizeOfTempRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t BufferPingPong_get_SizeOfTempRxBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum size of the temporary data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>function has no argument, because the maximum size is a global define. This value counts for all buffer instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the temporary buffer (this is the value of BUFFER_PINGPONG_RX_HEADROOM) </dd></dl>

</div>
</div>
<a id="ga0eff78cbd4cb2f862b2d5cb908585257" name="ga0eff78cbd4cb2f862b2d5cb908585257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eff78cbd4cb2f862b2d5cb908585257">&#9670;&#160;</a></span>BufferPingPong_get_StartPtrOfFilledTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * BufferPingPong_get_StartPtrOfFilledTxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the start point of the first free place in the Buffer Array, that is ready to send. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Start pointer of the buffer to be send, or NULL in case of an error </dd></dl>

</div>
</div>
<a id="ga10b065e8b2062f367f24ff5ec976af2f" name="ga10b065e8b2062f367f24ff5ec976af2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b065e8b2062f367f24ff5ec976af2f">&#9670;&#160;</a></span>BufferPingPong_get_StartPtrOfTempRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * BufferPingPong_get_StartPtrOfTempRxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the start pointer of the temporary data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the temporary Rx buffer </dd></dl>

</div>
</div>
<a id="gac930abb339112617a8c77d49fd46cc56" name="gac930abb339112617a8c77d49fd46cc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac930abb339112617a8c77d49fd46cc56">&#9670;&#160;</a></span>BufferPingPong_init_StartConditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferPingPong_error_Td BufferPingPong_init_StartConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function once in the beginning to initialize the start conditions of the buffers data structure. BUFFER_PINGPONG_RX_MAX and BUFFER_PINGPONG_TX_MAX will be checked, if the value is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BUFFER_PINGPONG_NONE if everything is fine. </dd></dl>

</div>
</div>
<a id="ga0e5c4f95c7506ea13d72baa93faf6535" name="ga0e5c4f95c7506ea13d72baa93faf6535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e5c4f95c7506ea13d72baa93faf6535">&#9670;&#160;</a></span>BufferPingPong_latch_TempRxBufferToRegularRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferPingPong_error_Td BufferPingPong_latch_TempRxBufferToRegularRxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>Size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy all received data from the temporary buffer to the regular buffer. After latching, the temporary buffer is ready to be filled again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf82e195b46343a5f3d322ae3c226b974" name="gaf82e195b46343a5f3d322ae3c226b974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf82e195b46343a5f3d322ae3c226b974">&#9670;&#160;</a></span>BufferPingPong_queue_TxBytesToEmptyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferPingPong_error_Td BufferPingPong_queue_TxBytesToEmptyBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>Data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>Size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to queue data for transmission to the buffer that is free to be filled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
    <tr><td class="paramname">Data</td><td>pointer to the data to be buffered </td></tr>
    <tr><td class="paramname">Size</td><td>Number of bytes to be buffered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BUFFER_PINGPONG_NONE if everything is fine </dd></dl>

</div>
</div>
<a id="ga41cd11b371bd0c90d0283c21f4c0a6db" name="ga41cd11b371bd0c90d0283c21f4c0a6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41cd11b371bd0c90d0283c21f4c0a6db">&#9670;&#160;</a></span>BufferPingPong_toggle_RxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferPingPong_error_Td BufferPingPong_toggle_RxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the buffer that is used to receive data, so the filled one gets free to use. Make sure to fetch the Start pointer and size of the filled buffer before toggling! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BUFFER_PINGPONG_NONE if everything is fine </dd></dl>

</div>
</div>
<a id="gab80cc5f7a82bbf40a0f42bc2d18495ff" name="gab80cc5f7a82bbf40a0f42bc2d18495ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab80cc5f7a82bbf40a0f42bc2d18495ff">&#9670;&#160;</a></span>BufferPingPong_toggle_TxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BufferPingPong_error_Td BufferPingPong_toggle_TxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the buffer that is used to send data, so the other one gets free for processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BUFFER_PINGPONG_NONE if everything is fine </dd></dl>

</div>
</div>
<a id="ga0e17314f4db745d45752fd676a93a25a" name="ga0e17314f4db745d45752fd676a93a25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e17314f4db745d45752fd676a93a25a">&#9670;&#160;</a></span>ButterPingPong_fetch_StartPtrOfFilledRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * ButterPingPong_fetch_StartPtrOfFilledRxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_buffer_ping_pong__struct_td.html">BufferPingPong_structTd</a> *</td>          <td class="paramname"><span class="paramname"><em>Buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the start point of the RxArray that contains new data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buffer</td><td>pointer to the users Buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Start Pointer of the error. NULL in case of an error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
